chapter4 translate review

143 
테스트 실행 완료 후 `test_runner` 함수가 반환"되어" 제어 흐름이 `test_main` 함수로 돌아오고,
 다시 이 함수가 반환"되어" `_start` 함수로 제어 흐름이 돌아갑니다.
  실행 시작 함수는 반환할 수 없기에 `_start` 함수의 맨 끝에서 무한 루프에 진입하는데,
   `cargo test`"의" 실행 완료 후 종료하기를 바라는 우리의 입장에서는 해결해야 할 문제입니다.

`test_runner`는 짧은 디버그 메시지를 출력한 후 주어진 리스트의 각 테스트 함수를 호출합니다. 인자 타입 `&[& dyn Fn()]`은 [_Fn()_] 트레이트를 구현하는 타입에 대한 레퍼런스들의 [_slice_]입니다. 좀 더 쉽게 말하면 이것은 함수처럼 호출될 수 있는 타입에 대한 레퍼런스들의 리스트입니다. `test_runner` 함수는 테스트 용도 외에 쓸모가 없기에 `#[cfg(test)]` 속성을 적용하여 테스트 시에만 빌드합니다.

147 
`_start` 함수의 맨 뒤에 무한루프가 있"어" `cargo test`의 실행을 종료하려면 
실행 중인 QEMU를 수동으로 종료해야 합니다. 이 때문에 각종 명령어 스크립트에서 사람의 개입 없이는 `cargo test`를 사용할 수 없습니다. 이 불편을 해소하는 가장 직관적인 방법은 정식으로 운영체제를 종료하는 기능을 구현하는 것입니다.
하지만 이를 구현하려면 [APM] 또는 [ACPI] 전원 제어 표준을 지원하도록 커널 코드를 짜야 해서 제법 복잡한 작업이 될 것입니다.

381
`serial_println` 매크로에 `#[macro_export]` 속성을 적용"하여 이제" 이 매크로는 프로젝트 루트 네임스페이스에 배정되어 있습니다.
따라서 `use crate::serial::serial_println`을 이용해서는 해당 함수를 불러올 수 없습니다. 

449 
테스트 용 패닉 핸들러에서는 `println` 대신 `serial_println`을 사용하고, 
"del(또한)" QEMU"는" 실행 실패를 나타내는 종료 코드를 반환하며 종료"됩니다". 
컴파일러는 `isa-debug-exit` 장치가 프로그램을 종료시킨다는 것을 알지 못하기에, 
`exit_qemu` 호출 이후의 무한 루프는 여전히 필요합니다.

*474
"우린 이제" `isa-debug-exit` 장치와 시리얼 포트를 통해 모든 테스트 결과"를 보고하므로"
"더이상" QEMU 윈도우 창"이" 필요"하지 않습니다."
`-display none` 인자를 QEMU에 전달하면 QEMU 윈도우 창을 숨길 수 있습니다:

492
`cargo test`는 test_runner가 종료할 때까지 기다리기 때문에,
 실행이 끝나지 않는 테스트가 있다면 test_runner와 `cargo test`"는 영원히" 종료"되지 않을 수 있습니다"
 일반적인 소프트웨어 개발 상황에서는 무한 루프를 방지하는 것이 어렵지 않습니다. 
 하지만 커널을 작성하는 경우에는 다양한 상황에서 무한 루프가 발생할 수 있습니다:

494
- 부트로더가 커널을 불러오는 것에 실패하는 경우, 시스템"은" 무한히 재부팅을 시도합니다.
495
- BIOS/UEFI 펌웨어가 부트로더를 불러오는 것에 실패하는 경우, 시스템"은" 무한히 재부팅을 시도합니다.
499
무한 루프가 발생할 수 있는 경우의 수가 너무 많기에 `bootimage` 도구는 각 테스트 실행에 5분"의" 시간 제한을 적용합니다.
 제한 시간 안에 테스트 실행이 끝나지 않는다면 해당 테스트의 실행은 실패한 것으로 표기되며 "Timed Out"라는 오류 메시지가 콘솔에 출력됩니다.
  덕분에 무한 루프에 갇힌 테스트가 있어도 `cargo test`의 실행이 무한히 지속되지는 않습니다.

512
`trivial_assertion` 테스트가 타임아웃 되도록 5분"동안" | "이나" 기다리고 싶지 않다면 위의 `test-timeout` 값을 낮추세요.

561
함수명을 출력한 후 `self()`를 통해 테스트 함수를 호출합니다. 
`self`가 `Fn()` 트레이트를 구현한다는 조건을 걸어놨기 때문에 이것이 가능합니다. 
테스트 함수가 반환"된" 후, `[ok]` 메시지를 출력하여 테스트 함수가 패닉하지 않았다는 것을 알립니다.

*598
함수의 크레이트 네임스페이스 안에서의 "전체" 경로가 함수 이름으로 출력됩니다. 
크레이트 내 다른 모듈들이 같은 이름의 테스트를 갖더라도 구분할 수 있습니다. 
그 외에 출력 내용이 크게 달라진 것은 없고, 매번 print문을 직접 입력해야 하는 번거로움을 덜었습니다.

*772
`lib.rs`는 `main.rs`와는 독립적으로 테스트됩니다. 
그렇기에 라이브러리를 테스트 모드로 빌드할 경우 "del(할 경우를 위해)" 실행 시작 함수 `_start` 및 패닉 핸들러를 별도로 제공해야 합니다.
 [`cfg_attr`] 속성을 사용하여 `no_main`"을 인자로 제공해 no_main 속성을 테스트 모드 빌드 시에 적용합니다."

`QemuExitcode` enum 과 `exit_qemu` 함수 또한 `src/lib.rs`로 옮기고 "public(pub)" 키워드를 달아줍니다:
776

798
이제 실행 파일 및 통합 테스트에서 이 라이브러리로부터 함수들을 불러와 사용할 수 있습니다. `println` 와 `serial_println` 
또한 사용 가능하도록 "del(하기 위해)" 모듈 선언을 `lib.rs`로 옮깁니다:
--


854
`src/main.rs`처럼 `tests/basic_boot.rs`에서도 우리가 만든 라이브러리에서 타입들을 "불러와 사용할" 수 있습니다.
855
"우린 이제" 필요했던 타입 정보들을 "불러와서" 테스트 작성을 마칠 수 있게 되었습니다:

870:
다시 `cargo test`를 시도하면 실행을 정상적으로 완료합니다. `lib.rs`와 `main.rs` 그리고 `basic_boot.rs` 각각의 빌드 및 테스트가 따로 실행되는 것을 확인하실 수 있습니다.
 `main.rs`와 통합 테스트 `basic_boot`의 경우"del(는)" `#[test_case]` 속성이 적용된 함수가 하나도 없"어" "Running 0 tests"라는 메시지가 출력됩니다.

897
- **CPU 예외**: 프로그램 코드가 허용되지 않은 작업을 실행하는 경우 (예: 0으로 나누기 연산), CPU는 예외 시그널을 반환합니다. 
커널은 이런 예외 상황에 대처할 예외 핸들러를 등록해놓을 수 있습니다. 
통합 테스트를 통해 CPU 예외 발생 시 알맞"은" 예외 핸들러가 호출되는지, 혹은 예외 처리 후 원래 실행 중이던 코드가 문제 없이 실행을 계속하는지 확인해볼 수 있습니다.
